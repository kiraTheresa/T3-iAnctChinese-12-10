# 修复古文解析对话功能本地缓存问题

## 问题分析

古文解析对话功能无法实现本地缓存的原因是：

1. **缓存键生成问题**：当前缓存键基于`content`的哈希值，即`${baseKey}_${contentHash}`
2. **组件挂载生命周期**：当用户从古文解析界面切换出去再回来时，组件会重新挂载
3. **content变化影响**：如果在切换过程中`content`发生变化，会导致缓存键变化，无法读取之前的缓存
4. **document切换影响**：当用户切换到不同document时，`content`会变化，导致缓存失效

## 修复方案

修改缓存机制，使用基于document ID的缓存键，而不是基于content的哈希值。

### 实现步骤

1. **修改ClassicalAnalysis组件的props**：

   * 从父组件Editor接收document ID作为props

2. **修改缓存键生成逻辑**：

   * 将`getUniqueKey`函数修改为基于document ID生成缓存键

   * 新的缓存键格式：`${baseKey}_${documentId}`

3. **更新父组件传递的props**：

   * 在Editor组件的render函数中，向ClassicalAnalysis传递document ID

### 代码修改点

1. **修改ClassicalAnalysis.jsx**：

   * 第8行：添加`documentId`到组件props

   * 第10-16行：修改`getUniqueKey`函数，使用documentId代替contentHash

   * 第1001行：在Editor组件中向ClassicalAnalysis传递doc.id

2. **更新依赖关系**：

   * 确保所有使用`getUniqueKey`的地方都正确使用新的缓存键生成逻辑

   * 更新相关useEffect的依赖数组

### 预期效果

* 当用户在同一个document中切换标签页时，回到古文解析界面能看到之前的对话历史

* 当用户切换到不同document时，会加载对应document的对话历史

* 对话历史和解析结果会基于document ID持久化保存到localStorage

### 技术要点

* 使用document ID作为缓存的唯一标识，确保同一文档的缓存不会因为content变化而丢失

* 保持现有的localStorage缓存机制，无需引入新的依赖

* 修改最小化，只更改缓存键生成逻辑，不影响其他功能

## 风险评估

* **低风险**：修改只涉及缓存键生成逻辑，不影响核心功能

* **向后兼容**：新的缓存键格式与旧格式不同，会为现有文档创建新的缓存，但不会覆盖旧缓存

* **性能影响**：document ID比content哈希值计算更简单，性能更好

## 测试建议

1. 测试在同一个document中切换标签页，回到古文解析界面是否能看到之前的对话历史
2. 测试切换到不同document，是否能加载对应document的对话历史
3. 测试刷新页面后，对话历史是否能正确恢复
4. 测试多个document的对话历史是否能正确隔离

